# -*- coding: utf-8 -*-
"""seq2seq_ped_predictions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u06XueavEOkuZubGh_RspAfQi7O2vApB
"""

from __future__ import print_function

from keras.models import Model
from keras.layers import Input, LSTM, Dense
import numpy as np
import pickle
import matplotlib.pyplot as plt

# Path to the traj data pickle file on disk.
#trajs_filename = 'trajs.p'
#with open(trajs_filename, "rb") as f:
#	dataset = pickle.load(f)

batch_size = 64  # Batch size for training.
latent_dim = 256  # Latent dimensionality of the encoding space.

max_encoder_seq_length = 10  # how many timesteps of history provided to seed the encoder
max_decoder_seq_length = 5  # how many timesteps decoder has to predict

num_encoder_tokens = 8  # how many elements in the input space (xy pos, xy vel per agent)
num_decoder_tokens = 2  # how many elements in the predicted space (xy pos)


# Split the array of trajectories into 3 arrays of traj snippets
def multivariate_data_3d(dataset, first_traj_index, last_traj_index, history_size,
                         target_size, step):
	encoder_input = []
	decoder_input = []
	decoder_target = []

	if last_traj_index is None:
		last_traj_index = len(dataset) + 1

	for traj in dataset[first_traj_index:last_traj_index]:
		target = traj[:, 0:2]
		start_index = 0 + history_size
		end_index = len(traj) - target_size
		for i in range(start_index, end_index):
			indices = range(i - history_size, i, step)
			encoder_input.append(traj[indices])
			decoder_input.append(target[i - 1:i + target_size - 1])
			decoder_target.append(target[i:i + target_size])

	return np.array(encoder_input), np.array(decoder_input), np.array(decoder_target)


#encoder_input_data, decoder_input_data, decoder_target_data = multivariate_data_3d(dataset, 0, None,
#                                                                                   max_encoder_seq_length,
#                                                                                   max_decoder_seq_length, 1)

#print(encoder_input_data.shape)
#print(decoder_input_data.shape)
#print(decoder_target_data.shape)

# print(encoder_input_data[0])
# print(decoder_input_data[0])
# print(decoder_target_data[0])

# Define an input sequence and process it.
encoder_inputs = Input(shape=(None, num_encoder_tokens))
encoder = LSTM(latent_dim, return_state=True)
encoder_outputs, state_h, state_c = encoder(encoder_inputs)
# We discard `encoder_outputs` and only keep the states.
encoder_states = [state_h, state_c]

# Set up the decoder, using `encoder_states` as initial state.
decoder_inputs = Input(shape=(None, num_decoder_tokens))
# We set up our decoder to return full output sequences,
# and to return internal states as well. We don't use the
# return states in the training model, but we will use them in inference.
decoder_lstm = LSTM(latent_dim, return_sequences=True, return_state=True)
decoder_outputs, _, _ = decoder_lstm(decoder_inputs,
                                     initial_state=encoder_states)
decoder_dense = Dense(num_decoder_tokens)
decoder_outputs = decoder_dense(decoder_outputs)

# Define the model that will turn
# `encoder_input_data` & `decoder_input_data` into `decoder_target_data`
model = Model([encoder_inputs, decoder_inputs], decoder_outputs)

EPOCHS = 2

# Run training
model.compile(optimizer='rmsprop', loss='mae')
history = model.fit([encoder_input_data, decoder_input_data], decoder_target_data,
                    batch_size=batch_size,
                    epochs=EPOCHS,
                    validation_split=0.2)
# Save model
model.save('s2s.h5')

# Plot training & validation loss values
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss during training')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Val'], loc='upper left')
plt.show()

# Next: inference mode (sampling).
# Here's the drill:
# 1) encode input and retrieve initial decoder state
# 2) run one step of decoder with this initial state
# and a "start of sequence" token as target.
# Output will be the next target token
# 3) Repeat with the current target token and current states

# Define sampling models
encoder_model = Model(encoder_inputs, encoder_states)

decoder_state_input_h = Input(shape=(latent_dim,))
decoder_state_input_c = Input(shape=(latent_dim,))
decoder_states_inputs = [decoder_state_input_h, decoder_state_input_c]
decoder_outputs, state_h, state_c = decoder_lstm(
	decoder_inputs, initial_state=decoder_states_inputs)
decoder_states = [state_h, state_c]
decoder_outputs = decoder_dense(decoder_outputs)
decoder_model = Model(
	[decoder_inputs] + decoder_states_inputs,
	[decoder_outputs] + decoder_states)


def decode_sequence(input_seq, encoder, decoder):
	# Encode the input as state vectors.
	states_value = encoder.predict(input_seq)

	# Populate the first character of target sequence with the start character.
	target_seq = np.zeros((1, 1, num_decoder_tokens))
	target_seq[0, 0, :] = input_seq[0, -1, 0:2]

	# Sampling loop for a batch of sequences
	# (to simplify, here we assume a batch of size 1).
	stop_condition = False
	decoded_sentence = np.zeros((max_decoder_seq_length, num_decoder_tokens))
	step = 0
	while not stop_condition:
		# Exit condition: either hit max length
		# or find stop character.
		if step >= max_decoder_seq_length - 1:
			stop_condition = True

		output_tokens, h, c = decoder.predict(
			[target_seq] + states_value)

		# Sample a token
		sampled_output = output_tokens[0, -1, :]

		decoded_sentence[step, :] = sampled_output

		# Update the target sequence (of length 1).
		target_seq = output_tokens

		# Update states
		states_value = [h, c]

		step += 1

	return decoded_sentence


def multi_step_plot(history, true_future, prediction):
	plt.figure(figsize=(12, 6))

	if history.ndim == 3:
		history = history[0]
	if true_future.ndim == 3:
		true_future = true_future[0]

	plt.plot(history[:, 0], history[:, 1], 'bx--', label='History')
	plt.plot(history[:, 4], history[:, 5], 'b^--', label='Other Agent History')
	plt.plot(true_future[:, 0], true_future[:, 1], 'bo', label='True Future')

	if prediction.any():
		plt.plot(prediction[:, 0], prediction[:, 1], 'ro',
		         label='Predicted Future')

	plt.axis('equal')
	plt.legend(loc='upper left')
	plt.show()


np.random.seed(1)
num_to_plot = 3
inds = np.arange(encoder_input_data.shape[0])
inds_to_plot = np.random.choice(inds, num_to_plot)
for seq_index in inds_to_plot:
	# Take one sequence (part of the training set)
	# for trying out decoding.
	input_seq = encoder_input_data[seq_index: seq_index + 1]
	true_output = decoder_target_data[seq_index:seq_index + 1]
	predicted_output = decode_sequence(input_seq, encoder_model, decoder_model)
	multi_step_plot(input_seq, true_output, predicted_output)
